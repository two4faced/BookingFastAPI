import datetime
from datetime import timezone, timedelta

from fastapi import HTTPException
from passlib.context import CryptContext
import jwt

from src.config import settings
from src.exceptions import UserNotFoundException, WrongPassOrEmailException
from src.schemas.users import UserRequestAdd, UserAdd, UserLogIn
from src.services.base import BaseService


class AuthService(BaseService):
    pwd_context = CryptContext(schemes=['bcrypt'], deprecated='auto')

    async def register_user(self, user_data: UserRequestAdd):
        hashed_password = self.hash_password(user_data.password)
        new_user_data = UserAdd(
            name=user_data.name,
            email=user_data.email,
            hashed_password=hashed_password,
        )

        await self.db.users.add(new_user_data)
        await self.db.commit()

    async def login_user(self, user_data: UserLogIn):
        is_user = await self.db.users.get_one_or_none(email=user_data.email)
        if not is_user:
            raise UserNotFoundException
        user = await self.db.users.get_user_with_hashed_pass(email=user_data.email)
        if not AuthService().verify_password(user_data.password, user.hashed_password):
            raise WrongPassOrEmailException
        access_token = AuthService().create_access_token({'user_id': user.id})

        return access_token

    async def get_me(self, user_id: int):
        user = await self.db.users.get_one_or_none(id=user_id)
        return user

    def create_access_token(self, data: dict) -> str:
        to_encode = data.copy()
        expire = datetime.datetime.now(timezone.utc) + timedelta(
            minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES
        )
        to_encode |= {'exp': expire}
        encoded_jwt = jwt.encode(
            to_encode, settings.JWT_SECRET_KEY, algorithm=settings.JWT_ALGORITHM
        )
        return encoded_jwt

    def hash_password(self, password: str) -> str:
        return self.pwd_context.hash(password)

    def verify_password(self, plain_password, hashed_password):
        return self.pwd_context.verify(plain_password, hashed_password)

    def decode_jwt(self, token: str) -> dict:
        try:
            return jwt.decode(
                token, key=settings.JWT_SECRET_KEY, algorithms=[settings.JWT_ALGORITHM]
            )
        except jwt.exceptions.DecodeError:
            raise HTTPException(status_code=401, detail='Неверный токен')
